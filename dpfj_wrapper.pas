unit dpfj_wrapper;
{ This unit is automatically generated by Chet:
  https://github.com/neslib/Chet }

{$MINENUMSIZE 4}

interface

const
  {$IF Defined(WIN32)}
  dpfj = 'dpfj.dll';
  _PU = '';
  {$ELSE}
    {$MESSAGE Error 'Unsupported platform'}
  {$IFEND}

const
  { TODO : Macro refers to system symbol "__stdcall": }
  (* DPAPICALL __stdcall *)
  { TODO : Macro probably uses invalid symbol "void": }
  (* NULL ( ( void * ) 0 ) *)
  _DP_FACILITY = $05BA;
  { TODO : Unable to convert function-like macro: }
  (* DPERROR ( err ) ( ( int ) err | ( _DP_FACILITY << 16 ) ) *)
  DPFJ_API_VERSION_MAJOR = 1;
  DPFJ_API_VERSION_MINOR = 0;
  DPFJ_SUCCESS = 0;
  { TODO : Macro uses commented-out symbol "DPERROR": }
  (* DPFJ_E_NOT_IMPLEMENTED DPERROR ( 0x0a ) *)
  { TODO : Macro uses commented-out symbol "DPERROR": }
  (* DPFJ_E_FAILURE DPERROR ( 0x0b ) *)
  { TODO : Macro uses commented-out symbol "DPERROR": }
  (* DPFJ_E_NO_DATA DPERROR ( 0x0c ) *)
  { TODO : Macro uses commented-out symbol "DPERROR": }
  (* DPFJ_E_MORE_DATA DPERROR ( 0x0d ) *)
  { TODO : Macro uses commented-out symbol "DPERROR": }
  (* DPFJ_E_INVALID_PARAMETER DPERROR ( 0x14 ) *)
  { TODO : Macro uses commented-out symbol "DPERROR": }
  (* DPFJ_E_INVALID_FID DPERROR ( 0x65 ) *)
  { TODO : Macro uses commented-out symbol "DPERROR": }
  (* DPFJ_E_TOO_SMALL_AREA DPERROR ( 0x66 ) *)
  { TODO : Macro uses commented-out symbol "DPERROR": }
  (* DPFJ_E_INVALID_FMD DPERROR ( 0xc9 ) *)
  { TODO : Macro uses commented-out symbol "DPERROR": }
  (* DPFJ_E_ENROLLMENT_IN_PROGRESS DPERROR ( 0x12d ) *)
  { TODO : Macro uses commented-out symbol "DPERROR": }
  (* DPFJ_E_ENROLLMENT_NOT_STARTED DPERROR ( 0x12e ) *)
  { TODO : Macro uses commented-out symbol "DPERROR": }
  (* DPFJ_E_ENROLLMENT_NOT_READY DPERROR ( 0x12f ) *)
  { TODO : Macro uses commented-out symbol "DPERROR": }
  (* DPFJ_E_ENROLLMENT_INVALID_SET DPERROR ( 0x130 ) *)
  DPFJ_PROBABILITY_ONE = $7fffffff;
  DPFJ_FID_ANSI_381_2004 = $001B0401;
  DPFJ_FID_ISO_19794_4_2005 = $01010007;
  DPFJ_FMD_ANSI_378_2004 = $001B0001;
  DPFJ_FMD_ISO_19794_2_2005 = $01010001;
  DPFJ_FMD_DP_PRE_REG_FEATURES = 0;
  DPFJ_FMD_DP_REG_FEATURES = 1;
  DPFJ_FMD_DP_VER_FEATURES = 2;
  DPFJ_FMD_DP_PLATINUM_REG_FEATURES = 3;
  DPFJ_POSITION_UNKNOWN = 0;
  DPFJ_POSITION_RTHUMB = 1;
  DPFJ_POSITION_RINDEX = 2;
  DPFJ_POSITION_RMIDDLE = 3;
  DPFJ_POSITION_RRING = 4;
  DPFJ_POSITION_RLITTLE = 5;
  DPFJ_POSITION_LTHUMB = 6;
  DPFJ_POSITION_LINDEX = 7;
  DPFJ_POSITION_LMIDDLE = 8;
  DPFJ_POSITION_LRING = 9;
  DPFJ_POSITION_LLITTLE = 10;
  DPFJ_SCAN_LIVE_PLAIN = 0;
  DPFJ_SCAN_LIVE_ROLLED = 1;
  DPFJ_SCAN_NONLIVE_PLAIN = 2;
  DPFJ_SCAN_NONLIVE_ROLLED = 3;
  DPFJ_SCAN_SWIPE = 8;
  DPFJ_ENGINE_DPFJ = 0;
  DPFJ_ENGINE_INNOVATRICS_ANSIISO = 1;
  DPFJ_ENGINE_DPFJ7 = 2;
  DPFJ_FID_ANSI_381_2004_RECORD_HEADER_LENGTH = 36;
  DPFJ_FID_ISO_19794_4_2005_RECORD_HEADER_LENGTH = 32;
  DPFJ_FID_ANSI_ISO_VIEW_HEADER_LENGTH = 14;
  DPFJ_FMD_ANSI_378_2004_RECORD_HEADER_LENGTH = 26;
  DPFJ_FMD_ISO_19794_2_2005_RECORD_HEADER_LENGTH = 24;
  DPFJ_FMD_ANSI_ISO_VIEW_HEADER_LENGTH = 4;
  DPFJ_FMD_ANSI_ISO_MINITIA_LENGTH = 6;
  MAX_FMD_SIZE = (DPFJ_FMD_ANSI_378_2004_RECORD_HEADER_LENGTH+DPFJ_FMD_ANSI_ISO_VIEW_HEADER_LENGTH+255*DPFJ_FMD_ANSI_ISO_MINITIA_LENGTH+2);
  { TODO : Macro uses commented-out symbol "DPERROR": }
  (* DPFJ_E_COMPRESSION_IN_PROGRESS DPERROR ( 0x141 ) *)
  { TODO : Macro uses commented-out symbol "DPERROR": }
  (* DPFJ_E_COMPRESSION_NOT_STARTED DPERROR ( 0x142 ) *)
  { TODO : Macro uses commented-out symbol "DPERROR": }
  (* DPFJ_E_COMPRESSION_INVALID_WSQ_PARAMETER DPERROR ( 0x14a ) *)
  { TODO : Macro uses commented-out symbol "DPERROR": }
  (* DPFJ_E_COMPRESSION_WSQ_FAILURE DPERROR ( 0x14b ) *)
  { TODO : Macro uses commented-out symbol "DPERROR": }
  (* DPFJ_E_COMPRESSION_WSQ_LIB_NOT_FOUND DPERROR ( 0x14c ) *)
  DPFJ_COMPRESSION_WSQ_NIST = 1;
  DPFJ_COMPRESSION_WSQ_AWARE = 2;
  { TODO : Macro uses commented-out symbol "DPERROR": }
  (* DPFJ_E_QUALITY_NO_IMAGE DPERROR ( 0x15e ) *)
  { TODO : Macro uses commented-out symbol "DPERROR": }
  (* DPFJ_E_QUALITY_TOO_FEW_MINUTIA DPERROR ( 0x15f ) *)
  { TODO : Macro uses commented-out symbol "DPERROR": }
  (* DPFJ_E_QUALITY_FAILURE DPERROR ( 0x160 ) *)
  { TODO : Macro uses commented-out symbol "DPERROR": }
  (* DPFJ_E_QUALITY_LIB_NOT_FOUND DPERROR ( 0x161 ) *)
  DPFJ_QUALITY_NFIQ_NIST = 1;
  DPFJ_QUALITY_NFIQ_AWARE = 2;

type
  // Forward declarations
  PPByte = ^PByte;
  Pdpfj_ver_info = ^dpfj_ver_info;
  Pdpfj_version = ^dpfj_version;
  Pdpfj_candidate = ^dpfj_candidate;
  Pdpfj_fid_record_params = ^dpfj_fid_record_params;
  Pdpfj_fid_view_params = ^dpfj_fid_view_params;
  Pdpfj_fmd_record_params = ^dpfj_fmd_record_params;
  Pdpfj_fmd_view_params = ^dpfj_fmd_view_params;

  (** 
  \brief Fingerprint Image Data (FID) Format.
   *)
  DPFJ_FID_FORMAT = Integer;
  (**
  \brief Fingerptint Minutiae Data (FMD) Format.
   *)
  DPFJ_FMD_FORMAT = Integer;
  (** \brief Defines finger position.
  	
  Finger position according to ANSI 378-2004 and ISO 19794-2-2005 standards.
   *)
  DPFJ_FINGER_POSITION = Integer;
  (** 
  \brief Defines impression type.
  
  Impression type according to ANSI 378-2004 and ISO 19794-2-2005 standards
   *)
  DPFJ_SCAN_TYPE = Integer;
  (**
  \brief Defines matching engine to use.
   *)
  DPFJ_ENGINE_TYPE = Integer;
  (** 
  \brief Reader handle. 
  
  Reader handle acquired by calling dpfpdd_open().
   *)
  DPFJ_DEV = Pointer;

  (**
  \brief API Version information. 
   *)
  dpfj_ver_info = record
    (** major version number *)
    major: Integer;
    (** minor version number *)
    minor: Integer;
    (** maintenance or revision number *)
    maintenance: Integer;
  end;

  (**
  \brief Complete information about library/SDK.
   *)
  dpfj_version = record
    (** Size of the structure, in bytes *)
    size: Cardinal;
    (** file version of the library/SDK *)
    lib_ver: DPFJ_VER_INFO;
    (** version of the API *)
    api_ver: DPFJ_VER_INFO;
  end;

  (**
  \brief Candidate, result of identification.
   *)
  dpfj_candidate = record
    (** size of the structure, in bytes *)
    size: Cardinal;
    (** index of the FMD in the input array *)
    fmd_idx: Cardinal;
    (** index of the view in the FMD *)
    view_idx: Cardinal;
  end;

  (** 
  	\brief Define image properties.
  	
  	Structure defines image properties for FIDs in ANSI 381-2004 
  	and ISO 19794-4-2005 formats.
   *)
  dpfj_fid_record_params = record
    (** total length of the image, including headers and all views *)
    record_length: Cardinal;
    (** CBEFF product identifier *)
    cbeff_id: Cardinal;
    (** vendor specified *)
    capture_device_id: Cardinal;
    (** from Table 1 in "ANSI INSITS 381-2004" *)
    acquisition_level: Cardinal;
    (** total number of fingerprints in the record, must be greater or equal to 1 *)
    finger_cnt: Cardinal;
    (** pixels/cm (2) or pixels/inch (1) *)
    scale_units: Cardinal;
    (** scan resolution *)
    scan_res: Cardinal;
    (** image resolution *)
    image_res: Cardinal;
    (** pixel depth, 1 - 16 bits *)
    bpp: Cardinal;
    (** from Table 3 in "ANSI INSITS 381-2004" *)
    compression: Cardinal;
  end;

  (**
  	\brief Define fingerprint image view (FIV) properties.
  	
  	Structure defines image view properties for FIVs in ANSI 381-2004 
  	and ISO 19794-4-2005 formats.
   *)
  dpfj_fid_view_params = record
    (** total length of the finger data including header *)
    data_length: Cardinal;
    (** finger position  *)
    finger_position: DPFJ_FINGER_POSITION;
    (** number of views associated with this finger, must be greater or equal to 1 *)
    view_cnt: Cardinal;
    (** 1 - 256 *)
    view_number: Cardinal;
    (** 1 - 100 for ISO; 1 - 100, 254 for ANSI *)
    quality: Cardinal;
    (** impression type *)
    impression_type: DPFJ_SCAN_TYPE;
    (** width of the fingerprint view, in pixels *)
    width: Cardinal;
    (** height of the fingerprint view, in pixels *)
    height: Cardinal;
    (** pointer to the view data *)
    view_data: PByte;
  end;

  (**
  	\brief Define FMD properties.
  	
  	Structure defines minutiae data properties for FMDs in ANSI 378-2004 
  	and ISO 19794-2-2005 formats.
   *)
  dpfj_fmd_record_params = record
    (** total length of the image, including headers and all views *)
    record_length: Cardinal;
    (** CBEFF product identifier *)
    cbeff_id: Cardinal;
    (** 4 bits: compliance;  *)
    capture_equipment_comp: Cardinal;
    (** 12 bits: capture device id, vendor specified *)
    capture_equipment_id: Cardinal;
    (** width of the fingerprint image, in pixels *)
    width: Cardinal;
    (** height of the fingerprint image, in pixels *)
    height: Cardinal;
    (** resolution of the fingerprint image *)
    resolution: Cardinal;
    (** number of views *)
    view_cnt: Cardinal;
  end;

  (**
  	\brief Define fingerprint minutiae view (FMV) properties.
  	
  	Structure defines minutiae view properties for FMVs in ANSI 378-2004 
  	and ISO 19794-2-2005 formats.
   *)
  dpfj_fmd_view_params = record
    (** 0 - 10, from Table 5 in "ANSI INSITS 381-2004" *)
    finger_position: DPFJ_FINGER_POSITION;
    (** 0 - 15 *)
    view_number: Cardinal;
    (** Table 2 in "ANSI INSITS 378-2004" *)
    impression_type: DPFJ_SCAN_TYPE;
    (** 1 - 100  *)
    quality: Cardinal;
    (** number of minutiae *)
    minutia_cnt: Cardinal;
    (** length of the extended data block, in bytes *)
    ext_block_length: Cardinal;
    (** pointer to the extended data block *)
    ext_block: PByte;
  end;

  (**
  \brief Compression algorithm to use.
   *)
  DPFJ_COMPRESSION_ALGORITHM = Integer;
  (**
  \brief Quality algorithm to use.
   *)
  DPFJ_QUALITY_ALGORITHM = Integer;

(**
	\brief Query the library and API version information. 
	
	\param ver  		[in] Pointer to the empty structure (per DPFJ_VERSION); [out] Pointer to structure containing version information
	\return DPFJ_SUCCESS:   Version information was acquired;
	\return DPFJ_E_FAILURE: Failed to acquire version information.
 *)
//manually edited:
//Original dpfj_version(...): Integer;
//changed to show_dpfj_version(...): Integer;
//Reason because, compiler recognize same name as record object and function
function show_dpfj_version(ver: PDPFJ_VERSION): Integer; stdcall;
  external dpfj name _PU + 'dpfj_version';

(**
	\brief Select matching engine. 

	DigitalPersona FingerJet is default engine used if this function is not called. FingerJet is available on all platforms and does not require
	open reader (parameter hdev can be NULL). Not every other engine is available on every platform. Some engines require valid handle from 
	opened reader to be supplied.
	
	\param hdev 		[in] Reader handle.
	\param engine  		[in] Matching engine to use.
	\return DPFJ_SUCCESS:           Engine is selected;
	\return DPFJ_E_NOT_IMPLEMENTED: Requested engine is not supported of this platform.
 *)
function dpfj_select_engine(hdev: DPFJ_DEV; engine: DPFJ_ENGINE_TYPE): Integer; stdcall;
  external dpfj name _PU + 'dpfj_select_engine';

(**
	\brief Extracts features and creates an FMD from a raw image. 

	When you do a fingerprint capture, you can receive a raw image or a FID. If you specify a raw image, you can then extract features into an FMD using this function.
	The raw image is just a buffer of pixels. This function works with raw images that have
	 - 8 bits per pixel
	 - no padding
	 - square pixels (dpi is the same for horizontal and vertical)

	The size of the resulting FMD will vary depending on the minutiae in a specific fingerprint.  The maximum possible size of a single-view FMD is MAX_FMD_SIZE. 
	If the value pointed to by fmd_size is zero, the function will return with the error code DPFJ_E_MORE_DATA and the required size will be stored in the 
	value pointed to by fmd_size. In order to determine the size, this function processes the image, extracts features and discards the FMD, so it takes significant
	processing time.  However if memory shortages are a key issue, this allows you to allocate memory more efficiently at the expense of processing time.
	If memory is available, you will get the best performance if you always allocate MAX_FMD_SIZE for the FMD.
	The value pointed to by fmd_size will always be returned as the actual size of the FMD that was extracted.	

	\param image_data    pointer to the image data
	\param image_size    size of the image data
	\param image_width   width of the image
	\param image_height  height of the image
	\param image_dpi     resolution of the image
	\param finger_pos    position of the finger
	\param cbeff_id      CBEFF product ID, from IBIA registry
	\param fmd_type      type of the FMD
	\param fmd           pointer to recieve FMD
	\param fmd_size      pointer to allocated size for the FMD, pointer to receive the actual size of the FMD
	\return DPFJ_SUCCESS:             FMD was created;
	\return DPFJ_E_MORE_DATA:         Features extracted, but allocated memory is not sufficient for FMD. The required memory size is in the fmd_size.
	\return DPFJ_E_INVALID_PARAMETER: One or more parameters passed are invalid.
	\return DPFJ_E_FAILURE:           Failed to create FMD.
 *)
function dpfj_create_fmd_from_raw(const image_data: PByte; image_size: Cardinal; image_width: Cardinal; image_height: Cardinal; image_dpi: Cardinal; finger_pos: DPFJ_FINGER_POSITION; cbeff_id: Cardinal; fmd_type: DPFJ_FMD_FORMAT; fmd: PByte; fmd_size: PCardinal): Integer; stdcall;
  external dpfj name _PU + 'dpfj_create_fmd_from_raw';

(**
	\brief Extracts features and creates an FMD from an ANSI or ISO image. 
	
	This function works with FIDs that have
	 - 8 bits per pixel
	 - no padding
	 - square pixels (dpi is the same for horizontal and vertical)
	The size of the resulting FMD will vary depending on the minutiae in a specific fingerprint.  The maximum possible size of a single-view FMD is MAX_FMD_SIZE. 
	If the value pointed to by fmd_size is zero, the function will return with the error code DPFJ_E_MORE_DATA and the required size will be stored in the value 
	pointed to by fmd_size. In order to determine the size, this function processes the image, extracts the FMD and discards the FMD, so it takes significant processing time.  
	However if memory shortages are a key issue, this allows you to allocate memory more efficiently at the expense of processing time.
	If memory is available, you will get the best performance if you always allocate MAX_FMD_SIZE for the FMD.
	The value pointed to by fmd_size will always be returned as the actual size of the FMD that was extracted.

	\param fid_type  type of the FID
	\param fid       pointer to the FID data
	\param fid_size  size of the FID data
	\param fmd_type  type of the FMD
	\param fmd       pointer to recieve FMD data
	\param fmd_size  pointer to allocated size for the FMD, pointer to receive the actual size of the FMD
	\return DPFJ_SUCCESS:             FMD was created;
	\return DPFJ_E_MORE_DATA:         Features extracted, but allocated memory is not sufficient for FMD. The required memory size is in the fmd_size.
	\return DPFJ_E_INVALID_PARAMETER: One or more parameters passed are invalid.
	\return DPFJ_E_FAILURE:           Failed to create FMD.
 *)
function dpfj_create_fmd_from_fid(fid_type: DPFJ_FID_FORMAT; const fid: PByte; fid_size: Cardinal; fmd_type: DPFJ_FMD_FORMAT; fmd: PByte; fmd_size: PCardinal): Integer; stdcall;
  external dpfj name _PU + 'dpfj_create_fmd_from_fid';

(**
	\brief Compares two fingerprints. 

	Given two single views from two FMDs, this function returns a <b>dissimilarity score</b> indicating the quality of the match.  
	The dissimilarity scores returned values are between:
		0=match
		maxint=no match
	Values close to 0 indicate very close matches, values closer to maxint indicate very poor matches.
	For a discussion of  how to evaluate dissimilarity scores, as well as the statistical validity of the dissimilarity score and error rates, consult the Developer Guide. 
	The dpfj_compare function returns DPFJ_SUCCESS if it is able to compare the fingerprints successfully (i.e., the FMDs are valid and correctly formed). 
	However that does not mean that the fingerprints matched. To check whether they matched, you must look at the dissimilarity score.

	\param fmd1_type        type of the first FMD
	\param fmd1             pointer to the first FMD
	\param fmd1_size        size of the first FMD
	\param fmd1_view_idx    index of the view
	\param fmd2_type        type of the second FMD
	\param fmd2             pointer to the second FMD
	\param fmd2_size size   of the second FMD
	\param fmd2_view_idx    index of the view
	\param score            pointer to receive dissimilarity score
	\return DPFJ_SUCCESS:   Comparison finished;
	\return DPFJ_E_FAILURE: Unknown error.
 *)
function dpfj_compare(fmd1_type: DPFJ_FMD_FORMAT; fmd1: PByte; fmd1_size: Cardinal; fmd1_view_idx: Cardinal; fmd2_type: DPFJ_FMD_FORMAT; fmd2: PByte; fmd2_size: Cardinal; fmd2_view_idx: Cardinal; score: PCardinal): Integer; stdcall;
  external dpfj name _PU + 'dpfj_compare';

(**
	\brief Compares a single fingerprint to an array of fingerprints.
	  
	This function takes as inputs:
		- a single view in an FMD
		- an array of FMDs (each FMD can contain up to 16 views) to compare
		- the desired number of candidates to return 
		- the threshold for False Positive Identification Rate that is permitted
	This function compares a single view against an array of FMDs.  Each time view has a score lower than the threshold, that view is marked as a possible candidate. 
	Then when all possible candidates are identified (i.e., they meet the threshold), they are ranked by their score.  Finally, the function returns as many 
	candidates as requested, based on the candidates with the lowest dissimilarity score.  
	For a discussion of setting the threshold as well as the statistical validity of the dissimilarity score and error rates, consult the Developer Guide.    
	
	\param fmd1_type         type of the FMDs
	\param fmd1              pointer to the first FMD data
	\param fmd1_size         size of the first FMD data
	\param fmd1_view_idx     index of the view
	\param fmds_type         type of the FMDs in the fmds array
	\param fmds_cnt          number of FMDs in the fmds array
	\param fmds              array of FMDs
	\param fmds_size         array of sizes of the FMDs data
	\param threshold_score   target threshold on degree of dissimilarity 
	\param candidate_cnt     [in] number of allocated entries in the candidates array; [out] receives the actual number of candidates filled in the array as a result of identification
	\param candidates        array of candidates
	\return DPFJ_SUCESS:    Identification finished;
	\return DPFJ_E_FAILURE: Unknown error.
 *)
function dpfj_identify(fmd1_type: DPFJ_FMD_FORMAT; fmd1: PByte; fmd1_size: Cardinal; fmd1_view_idx: Cardinal; fmds_type: DPFJ_FMD_FORMAT; fmds_cnt: Cardinal; fmds: PPByte; fmds_size: PCardinal; threshold_score: Cardinal; candidate_cnt: PCardinal; candidates: PDPFJ_CANDIDATE): Integer; stdcall;
  external dpfj name _PU + 'dpfj_identify';

(**
	\brief Starts enrollment operation.

	\param fmd_type type of FMD to produce as a result of enrollment operation
	\return DPFJ_SUCCESS:                  Enrollment started.
	\return DPFJ_E_INVALID_PARAMETER:      Requested FMD type is invalid.
	\return DPFJ_E_ENROLLMENT_IN_PROGRESS: Another enrollment operation is in prgress.
	\return DPFJ_E_FAILURE:                Unknown error.
 *)
function dpfj_start_enrollment(fmd_type: DPFJ_FMD_FORMAT): Integer; stdcall;
  external dpfj name _PU + 'dpfj_start_enrollment';

(**
	\brief Adds FMD to enrollment operation.

	Add an FMD to the pool of FMDs for enrollment and return a flag indicating when the enrollment is ready.
	This function must be called before dpfj_create_enrollment_fmd.

	\param fmd_type       type of the FMD.
	\param fmd            pointer to the FMD data.
	\param fmd_size       size of the FMD data.
	\param fmd_view_idx   index of the view
	\return DPFJ_SUCCESS:                  FMD added, enrollment is ready.
	\return DPFJ_E_MORE_DATA:              FMD added, more FMDs for enrollment required.
	\return DPFJ_E_INVALID_PARAMETER:      One or more parameters passed are invalid.
	\return DPFJ_E_ENROLLMENT_NOT_STARTED: Enrollment is not started.
	\return DPFJ_E_FAILURE:                Unknown error.
 *)
function dpfj_add_to_enrollment(fmd_type: DPFJ_FMD_FORMAT; fmd: PByte; fmd_size: Cardinal; fmd_view_idx: Cardinal): Integer; stdcall;
  external dpfj name _PU + 'dpfj_add_to_enrollment';

(**
	\brief Creates and returns enrollment FMD.

	Create an FMD for an enrolled finger. The output FMD is suitable for storing in a database of enrolled users.  
	Some applications like voting, banking and law enforcement require that you check for duplicate fingerprints before storing a new fingerprint in the database.
	For ANSI/ISO formats, the enrollment FMD is a standard FMD (the same as an FMD generated by the extraction function). For the DigitalPersona data format, 
	the enrollment FMD uses the "fingerprint template" format as used by legacy DigitalPersona applications.
	This function must be called after dpfj_add_to_enrollment.
	The size of the resulting FMD will vary depending on the minutiae in the fingerprint(s) that were enrolled.  The maximum possible size of an FMD is MAX_FMD_SIZE. 
	If the value pointed to by fmd_size is zero, the function will return with the error code DPFJ_E_MORE_DATA and the required size will be stored in the value pointed to by fmd_size. 
	In order to determine the size, this function processes the image, extracts features and discards the FMD, so it takes significant processing time.  
	However if memory shortages are a key issue, this allows you to allocate memory more efficiently at the expense of processing time.
	If memory is available, you will get the best performance if you always allocate MAX_FMD_SIZE for the FMD.
	The value pointed to by fmd_size will always be returned as the actual size of the FMD that was extracted.

	\param fmd            pointer to recieve FMD data
	\param fmd_size       pointer to allocated size for the FMD data, pointer to receive the actual size of the FMD data
	\return DPFJ_SUCCESS:                  FMD created.
	\return DPFJ_E_MORE_DATA:              FMD created, but allocated memory is not sufficient. The required memory size is in the fmd_size.
	\return DPFJ_E_INVALID_PARAMETER:      One or more parameters passed are invalid.
	\return DPFJ_E_ENROLLMENT_NOT_STARTED: Enrollment is not started.
	\return DPFJ_E_FAILURE:                Unknown error.
 *)
function dpfj_create_enrollment_fmd(fmd: PByte; fmd_size: PCardinal): Integer; stdcall;
  external dpfj name _PU + 'dpfj_create_enrollment_fmd';

(**
	\brief Ends enrollment operation, releases memory.

	This function releases resources used during the enrollment process.  Call after enrollment is complete.
	\return DPFJ_SUCCESS:   Enrollment ended.
	\return DPFJ_E_FAILURE: Unknown error.
 *)
function dpfj_finish_enrollment(): Integer; stdcall;
  external dpfj name _PU + 'dpfj_finish_enrollment';

(**
	\brief Converts an FMD from any supported format to any other supported format.
	
	\param fmd1_type  type of the input FMD
	\param fmd1       pointer to the input FMD data
	\param fmd1_size  size of the input FMD data
	\param fmd2_type  type of the target FMD
	\param fmd2       pointer to receive target FMD data
	\param fmd2_size  pointer to allocated size for the FMD data, pointer to receive the actual size of the FMD data
	\return DPFJ_SUCCESS:             FMD was converted;
	\return DPFJ_E_INVALID_PARAMETER: One or more parameters passed are invalid.
	\return DPFJ_E_FAILURE:           Failed to convert FMD.
 *)
function dpfj_fmd_convert(fmd1_type: DPFJ_FMD_FORMAT; fmd1: PByte; fmd1_size: Cardinal; fmd2_type: DPFJ_FMD_FORMAT; fmd2: PByte; fmd2_size: PCardinal): Integer; stdcall;
  external dpfj name _PU + 'dpfj_fmd_convert';

(**
	\brief Converts legacy DigitalPersona image to the image in ANSI or ISO format. 
	
	\param dp_image         pointer to the DP image data
	\param dp_image_size    size of the DP image data
	\param fid_type         type of the FID
	\param fid_dpi          resolution of the FID, valid values are 500 and 1000
	\param rotate180        flag: rotate image, 0 - do not rotate, 1 - rotate
	\param fid              pointer to receive FID data
	\param fid_size         pointer to receive the size of the FID
	\return DPFJ_SUCCESS:   FID was created
	\return DPFJ_E_FAILURE: Failed to create FID
 *)
function dpfj_dp_fid_convert(const dp_image: PByte; dp_image_size: Cardinal; fid_type: DPFJ_FID_FORMAT; fid_dpi: Cardinal; rotate180: Cardinal; fid: PByte; fid_size: PCardinal): Integer; stdcall;
  external dpfj name _PU + 'dpfj_dp_fid_convert';

(**
	\brief Converts raw image to the image in ANSI or ISO format. 
	
	\param image_data       pointer to the image data
	\param image_size       size of the image data
	\param image_width      width of the image
	\param image_height     height of the image
	\param image_dpi        resolution of the image
	\param finger_pos       position of the finger
	\param cbeff_id         CBEFF product ID, from IBIA registry
	\param fid_type         type of the FID
	\param fid_dpi          resolution of the FID, valid values are 500 and 1000
	\param rotate180        flag: rotate image, 0 - do not rotate, 1 - rotate
	\param fid              pointer to receive FID data
	\param fid_size         pointer to receive the size of the FID
	\return DPFJ_SUCCESS:   FID was created
	\return DPFJ_E_FAILURE: Failed to create FID
 *)
function dpfj_raw_convert(const image_data: PByte; image_size: Cardinal; image_width: Cardinal; image_height: Cardinal; image_dpi: Cardinal; finger_pos: DPFJ_FINGER_POSITION; cbeff_id: Cardinal; fid_type: DPFJ_FID_FORMAT; fid_dpi: Cardinal; rotate180: Cardinal; fid: PByte; fid_size: PCardinal): Integer; stdcall;
  external dpfj name _PU + 'dpfj_raw_convert';

(**
	\brief Read image properties from FID.
	
	\param image_type  type of the FID (per DPFJ_FID_FORMAT)
	\param image       pointer to the FID
	\param params      pointer to the structure to receive image properties
	\return void
 *)
procedure dpfj_get_fid_record_params(image_type: DPFJ_FID_FORMAT; const image: PByte; params: PDPFJ_FID_RECORD_PARAMS); stdcall;
  external dpfj name _PU + 'dpfj_get_fid_record_params';

(** 
	\brief Writes image properties to FID.
	
	\param params      pointer to the structure containing image properties
	\param image_type  format of the FID (per DPFJ_FID_FORMAT)
	\param image       pointer to the FID
	\return void
 *)
procedure dpfj_set_fid_record_params(const params: PDPFJ_FID_RECORD_PARAMS; image_type: DPFJ_FID_FORMAT; image: PByte); stdcall;
  external dpfj name _PU + 'dpfj_set_fid_record_params';

(**
	\brief Returns pointer to the specified view from FID.
	
	\param image_type  type of the FID (per DPFJ_FID_FORMAT)
	\param image       pointer to the FID
	\param view_idx    view index
	\return offset to the specified view
 *)
function dpfj_get_fid_view_offset(image_type: DPFJ_FID_FORMAT; const image: PByte; view_idx: Cardinal): Cardinal; stdcall;
  external dpfj name _PU + 'dpfj_get_fid_view_offset';

(**
	\brief Read image view properties from FID.
	
	\param view    pointer to the view from the FID
	\param params  pointer to the structure to receive view properties
	\return void
 *)
procedure dpfj_get_fid_view_params(const view: PByte; params: PDPFJ_FID_VIEW_PARAMS); stdcall;
  external dpfj name _PU + 'dpfj_get_fid_view_params';

(**
	\brief Write image view properties to FID.
	
	\param params  pointer to the structure containing view properties
	\param view    pointer to the view from the FID
	\return void
 *)
procedure dpfj_set_fid_view_params(const params: PDPFJ_FID_VIEW_PARAMS; view: PByte); stdcall;
  external dpfj name _PU + 'dpfj_set_fid_view_params';

(**
	\brief Read minutiae record properties from FMD.
	
	\param fmd_type   format of the FMD (per DPFJ_FMD_FORMAT)
	\param fmd        pointer to the FMD
	\param params     pointer to the structure to receive FMD properties
	\return void
 *)
procedure dpfj_get_fmd_record_params(fmd_type: DPFJ_FMD_FORMAT; const fmd: PByte; params: PDPFJ_FMD_RECORD_PARAMS); stdcall;
  external dpfj name _PU + 'dpfj_get_fmd_record_params';

(** \brief Write minutiae record properties to FMD.
	
	\param params     pointer to the structure containing FMD properties
	\param fmd_type   format of the FMD (per DPFJ_FMD_FORMAT)
	\param fmd        pointer to the FMD 
	\return void
 *)
procedure dpfj_set_fmd_record_params(const params: PDPFJ_FMD_RECORD_PARAMS; fmd_type: DPFJ_FMD_FORMAT; fmd: PByte); stdcall;
  external dpfj name _PU + 'dpfj_set_fmd_record_params';

(**
	\brief Return pointer to the specified view from FMD.
	
	\param fmd_type   format of the FMD (per DPFJ_FMD_FORMAT)
	\param fmd        pointer to the FMD
	\param view_idx   view index
	\return offset to the specified view
 *)
function dpfj_get_fmd_view_offset(fmd_type: DPFJ_FMD_FORMAT; const fmd: PByte; view_idx: Cardinal): Cardinal; stdcall;
  external dpfj name _PU + 'dpfj_get_fmd_view_offset';

(**
	\brief Read view properties from FMD.
	
	\param view    pointer to the view from the FMD
	\param params  pointer to the structure to receive view properties
	\return void
 *)
procedure dpfj_get_fmd_view_params(const view: PByte; params: PDPFJ_FMD_VIEW_PARAMS); stdcall;
  external dpfj name _PU + 'dpfj_get_fmd_view_params';

(**
	\brief Write view properties to FMD.
	
	\param params  pointer to the structure containing view properties
	\param view    pointer to the view from the FMD
	\return void
 *)
procedure dpfj_set_fmd_view_params(const params: PDPFJ_FMD_VIEW_PARAMS; view: PByte); stdcall;
  external dpfj name _PU + 'dpfj_set_fmd_view_params';

(**
	\brief Starts compression or decompression operation.

	\return DPFJ_SUCCESS:                   Operation started.
	\return DPFJ_E_COMPRESSION_IN_PROGRESS: Another operation is in progress.
	\return DPFJ_E_FAILURE:                 Unknown error.
 *)
function dpfj_start_compression(): Integer; stdcall;
  external dpfj name _PU + 'dpfj_start_compression';

(**
	\brief Sets target bitrate and tolerance for WSQ compression operation.

	\param bitrate_x100   Requested bitrate multiplied by 100. For example, to request bitrate of 4.19, pass 419.
	\param tolerance_aw   Sets tolerance in percents for the Aware WSQ compression. Range is 1 to 100. For NIST algorithm this parameter will be ignored.
	\return DPFJ_SUCCESS:                             Bitrate and tolerance are set.
	\return DPFJ_E_COMPRESSION_NOT_STARTED:           Operation is not started.
	\return DPFJ_E_COMPRESSION_INVALID_WSQ_PARAMETER: One or more parameters passed are invalid.
	\return DPFJ_E_FAILURE:                           Unknown error.
 *)
function dpfj_set_wsq_bitrate(bitrate_x100: Cardinal; tolerance_aw: Cardinal): Integer; stdcall;
  external dpfj name _PU + 'dpfj_set_wsq_bitrate';

(**
	\brief Sets target size and tolerance for WSQ compression operation.

	\param size           Requested size of compressed image.
	\param tolerance_aw   Sets tolerance in percents for the Aware WSQ compression. Range is 1 to 100. For NIST algorithm this parameter will be ignored.
	\return DPFJ_SUCCESS:                             Size and tolerance are set.
	\return DPFJ_E_COMPRESSION_NOT_STARTED:           Operation is not started.
	\return DPFJ_E_COMPRESSION_INVALID_WSQ_PARAMETER: One or more parameters passed are invalid.
	\return DPFJ_E_FAILURE:                           Unknown error.
 *)
function dpfj_set_wsq_size(size: Cardinal; tolerance_aw: Cardinal): Integer; stdcall;
  external dpfj name _PU + 'dpfj_set_wsq_size';

(**
	\brief Compresses FID.

	This function attempts to compress FID using Aware WSQ library (WSQ1000) or NIST algorithm. It's necessary to set target bitrate or
	target size before calling dpfj_compress_fid(). The function will allocate memory for the compressed FID. The resulting size of the
	compressed FID can be acquired by calling dpfj_get_processed_size(). The resulting size likely will differ from the requested size, or bitrate.
	How much the difference will be is dictated by the image, requested size or bitrate and tolerance (only for Aware algorithm).

	\param fid_type          type of the FID.
	\param fid               pointer to the FID data.
	\param fid_size          size of the FID data.
	\param compression_alg   compression algorithm to use, currently Aware WSQ and NIST WSQ algorithms are supported.
	\return DPFJ_SUCCESS:                             FID compressed.
	\return DPFJ_E_COMPRESSION_NOT_STARTED:           Operation is not started.
	\return DPFJ_E_COMPRESSION_INVALID_WSQ_PARAMETER: One or more parameters passed are invalid, or one or more parameters set for the operation are invalid.
	\return DPFJ_E_COMPRESSION_WSQ_LIB_NOT_FOUND:     Aware WSQ library is not found, or NIST WSQ algorithm is not built-in.
	\return DPFJ_E_COMPRESSION_WSQ_FAILURE:           Unknown error.
 *)
function dpfj_compress_fid(fid_type: DPFJ_FID_FORMAT; const fid: PByte; fid_size: Cardinal; compression_alg: DPFJ_COMPRESSION_ALGORITHM): Integer; stdcall;
  external dpfj name _PU + 'dpfj_compress_fid';

(**
	\brief Compresses raw image.

	This function attempts to compress image using Aware WSQ library (WSQ1000) or NIST algorithm. It's necessary to set target bitrate or
	target size before calling dpfj_compress_raw(). The function will allocate memory for the compressed image. The resulting size of the
	compressed image can be acquired by calling dpfj_get_processed_size(). The resulting size likely will differ from the requested size, or bitrate.
	How much the difference will be is dictated by the image, requested size or bitrate and tolerance (only for Aware algorithm).

	\param image_data        pointer to the image data
	\param image_size        size of the image data
	\param image_width       width of the image
	\param image_height      height of the image
	\param image_dpi         resolution of the image
	\param image_bpp         pixel depth of the image. Only 8bpp images are currently processed.
	\param compression_alg   compression algorithm to use, currently Aware WSQ and NIST WSQ algorithms are supported.
	\return DPFJ_SUCCESS:                             Image compressed.
	\return DPFJ_E_COMPRESSION_NOT_STARTED:           Operation is not started.
	\return DPFJ_E_COMPRESSION_INVALID_WSQ_PARAMETER: One or more parameters passed are invalid, or one or more parameters set for the operation are invalid.
	\return DPFJ_E_COMPRESSION_WSQ_LIB_NOT_FOUND:     Aware WSQ library is not found, or NIST WSQ algorithm is not built-in.
	\return DPFJ_E_COMPRESSION_WSQ_FAILURE:           Unknown error.
 *)
function dpfj_compress_raw(const image_data: PByte; image_size: Cardinal; image_width: Cardinal; image_height: Cardinal; image_dpi: Cardinal; image_bpp: Cardinal; compression_alg: DPFJ_COMPRESSION_ALGORITHM): Integer; stdcall;
  external dpfj name _PU + 'dpfj_compress_raw';

(**
	\brief Expands compressed FID.

	This function attempts to expand FID using Aware WSQ library (WSQ1000) or NIST algorithm. The function will allocate memory for the
	expanded FID. The resulting size of the expanded FID can be acquired by calling dpfj_get_processed_size().

	\param fid_type          type of the compressed FID.
	\param fid               pointer to the FID data.
	\param fid_size          size of the FID data.
	\param compression_alg   compression algorithm to use, currently Aware WSQ and NIST WSQ algorithms are supported.
	\return DPFJ_SUCCESS:                             FID expanded.
	\return DPFJ_E_COMPRESSION_NOT_STARTED:           Operation is not started.
	\return DPFJ_E_COMPRESSION_INVALID_WSQ_PARAMETER: One or more parameters passed are invalid.
	\return DPFJ_E_COMPRESSION_WSQ_LIB_NOT_FOUND:     Aware WSQ library is not found, or NIST WSQ algorithm is not built-in.
	\return DPFJ_E_COMPRESSION_WSQ_FAILURE:           Unknown error.
 *)
function dpfj_expand_fid(fid_type: DPFJ_FID_FORMAT; const fid: PByte; fid_size: Cardinal; compression_alg: DPFJ_COMPRESSION_ALGORITHM): Integer; stdcall;
  external dpfj name _PU + 'dpfj_expand_fid';

(**
	\brief Expands compressed raw image.

	This function attempts to expand FID using Aware WSQ library (WSQ1000) or NIST algorithm. The function will allocate memory for the
	expanded FID. The resulting size of the expanded FID can be acquired by calling dpfj_get_processed_size().

	\param image_data        pointer to the compressed image data
	\param image_size        size of the image data
	\param compression_alg   compression algorithm to use, currently Aware WSQ and NIST WSQ algorithms are supported.
	\param image_width       pointer to receive width of the image
	\param image_height      pointer to receive height of the image
	\param image_dpi         pointer to receive resolution of the image
	\param image_bpp         pointer to receive pixel depth of the image. Only 8bpp images are currently processed.
	\return DPFJ_SUCCESS:                             Image expanded.
	\return DPFJ_E_COMPRESSION_NOT_STARTED:           Operation is not started.
	\return DPFJ_E_COMPRESSION_INVALID_WSQ_PARAMETER: One or more parameters passed are invalid.
	\return DPFJ_E_COMPRESSION_WSQ_LIB_NOT_FOUND:     Aware WSQ library is not found, or NIST WSQ algorithm is not built-in.
	\return DPFJ_E_COMPRESSION_WSQ_FAILURE:           Unknown error.
 *)
function dpfj_expand_raw(const image_data: PByte; image_size: Cardinal; compression_alg: DPFJ_COMPRESSION_ALGORITHM; image_width: PCardinal; image_height: PCardinal; image_dpi: PCardinal; image_bpp: PCardinal): Integer; stdcall;
  external dpfj name _PU + 'dpfj_expand_raw';

(**
	\brief Returns the processed data.

	Application must determine the size of the data by calling dpfj_get_processed_data() and allocate memory to receive processed data.

	\param image_data        pointer to the allocated memory for the processed data
	\param image_size        size of the allocated memory
	\return DPFJ_SUCCESS:                             Processed data copied.
	\return DPFJ_E_COMPRESSION_NOT_STARTED:           Operation is not started.
	\return DPFJ_E_MORE_DATA:                         Allocated memory is not sufficient. The required memory size is in the image_size.
	\return DPFJ_E_COMPRESSION_INVALID_WSQ_PARAMETER: One or more parameters passed are invalid.
	\return DPFJ_E_COMPRESSION_WSQ_FAILURE:           Unknown error.
 *)
function dpfj_get_processed_data(image_data: PByte; image_size: PCardinal): Integer; stdcall;
  external dpfj name _PU + 'dpfj_get_processed_data';

(**
	\brief Ends compression or decompression operation, releases memory.

	This function releases resources used during the enrollment process.  Call after enrollment is complete.
	\return DPFJ_SUCCESS:   Operation ended.
	\return DPFJ_E_FAILURE: Unknown error.
 *)
function dpfj_finish_compression(): Integer; stdcall;
  external dpfj name _PU + 'dpfj_finish_compression';

(**
	\brief Calculates NFIQ score of the image in raw format.

	This function attempts to calculate NFIQ score of raw image using Aware WSQ library (WSQ1000) or NIST algorithm. 

	\param image_data    pointer to the image data
	\param image_size    size of the image data
	\param image_width   width of the image
	\param image_height  height of the image
	\param image_dpi     resolution of the image
	\param image_bpp     pixel depth of the image. Only 8bpp images are currently processed.
	\param quality_alg   NFIQ algorithm to use, currently Aware WSQ and NIST algorithms are supported.
	\param nfiq_score    pointer to the variable to receive NFIQ score.
	\return DPFJ_SUCCESS:                      NFIQ score calculated.
	\return DPFJ_E_QUALITY_INVALID_PARAMETER:  One or more parameters passed are invalid, or one or more parameters set for the operation are invalid.
	\return DPFJ_E_QUALITY_TOO_FEW_MINUTIA:    Too few minutia detected in the fingerprint image.
	\return DPFJ_E_QUALITY_LIB_NOT_FOUND:      Aware WSQ library is not found, or NIST WSQ algorithm is not built-in.
	\return DPFJ_E_QUALITY_FAILURE:            Unknown error.
 *)
function dpfj_quality_nfiq_from_raw(const image_data: PByte; image_size: Cardinal; image_width: Cardinal; image_height: Cardinal; image_dpi: Cardinal; image_bpp: Cardinal; quality_alg: DPFJ_QUALITY_ALGORITHM; nfiq_score: PCardinal): Integer; stdcall;
  external dpfj name _PU + 'dpfj_quality_nfiq_from_raw';

(**
	\brief Calculates NFIQ score of the view in the FID.

	This function attempts to calculate NFIQ score of single view in the FID using Aware WSQ library (WSQ1000) or NIST algorithm. 

	\param fid_type      type of the FID.
	\param fid           pointer to the FID data.
	\param fid_size      size of the FID data.
	\param view_idx      index of the view.
	\param quality_alg   NFIQ algorithm to use, currently Aware WSQ and NIST algorithms are supported.
	\param nfiq_score    pointer to the variable to receive NFIQ score.
	\return DPFJ_SUCCESS:                      NFIQ score calculated.
	\return DPFJ_E_QUALITY_INVALID_PARAMETER:  One or more parameters passed are invalid, or one or more parameters set for the operation are invalid.
	\return DPFJ_E_QUALITY_TOO_FEW_MINUTIA:    Too few minutia detected in the fingerprint image.
	\return DPFJ_E_QUALITY_LIB_NOT_FOUND:      Aware WSQ library is not found, or NIST WSQ algorithm is not built-in.
	\return DPFJ_E_QUALITY_FAILURE:            Unknown error.
 *)
function dpfj_quality_nfiq_from_fid(fid_type: DPFJ_FID_FORMAT; const fid: PByte; fid_size: Cardinal; view_idx: Cardinal; quality_alg: DPFJ_QUALITY_ALGORITHM; nfiq_score: PCardinal): Integer; stdcall;
  external dpfj name _PU + 'dpfj_quality_nfiq_from_fid';

implementation

end.