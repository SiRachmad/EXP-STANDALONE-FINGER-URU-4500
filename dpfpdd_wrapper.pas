unit dpfpdd_wrapper;
{ This unit is automatically generated by Chet:
  https://github.com/neslib/Chet }

{$MINENUMSIZE 4}

interface

const
  {$IF Defined(WIN32)}
  dpfpdd = 'dpfpdd.dll';
  _PU = '';
  {$ELSE}
    {$MESSAGE Error 'Unsupported platform'}
  {$IFEND}

const
  { TODO : Macro refers to system symbol "__stdcall": }
  (* DPAPICALL __stdcall *)
  { TODO : Macro probably uses invalid symbol "void": }
  (* NULL ( ( void * ) 0 ) *)
  _DP_FACILITY = $05BA;
  { TODO : Unable to convert function-like macro: }
  (* DPERROR ( err ) ( ( int ) err | ( _DP_FACILITY << 16 ) ) *)
  DPFPDD_API_VERSION_MAJOR = 1;
  DPFPDD_API_VERSION_MINOR = 10;
  DPFPDD_SUCCESS = 0;
  { TODO : Macro uses commented-out symbol "DPERROR": }
  (* DPFPDD_E_NOT_IMPLEMENTED DPERROR ( 0x0a ) *)
  { TODO : Macro uses commented-out symbol "DPERROR": }
  (* DPFPDD_E_FAILURE DPERROR ( 0x0b ) *)
  { TODO : Macro uses commented-out symbol "DPERROR": }
  (* DPFPDD_E_NO_DATA DPERROR ( 0x0c ) *)
  { TODO : Macro uses commented-out symbol "DPERROR": }
  (* DPFPDD_E_MORE_DATA DPERROR ( 0x0d ) *)
  { TODO : Macro uses commented-out symbol "DPERROR": }
  (* DPFPDD_E_INVALID_PARAMETER DPERROR ( 0x14 ) *)
  { TODO : Macro uses commented-out symbol "DPERROR": }
  (* DPFPDD_E_INVALID_DEVICE DPERROR ( 0x15 ) *)
  { TODO : Macro uses commented-out symbol "DPERROR": }
  (* DPFPDD_E_DEVICE_BUSY DPERROR ( 0x1e ) *)
  { TODO : Macro uses commented-out symbol "DPERROR": }
  (* DPFPDD_E_DEVICE_FAILURE DPERROR ( 0x1f ) *)
  { TODO : Macro uses commented-out symbol "DPERROR": }
  (* DPFPDD_E_PAD_LIBRARY DPERROR ( 0x21 ) *)
  { TODO : Macro uses commented-out symbol "DPERROR": }
  (* DPFPDD_E_PAD_DATA DPERROR ( 0x22 ) *)
  { TODO : Macro uses commented-out symbol "DPERROR": }
  (* DPFPDD_E_PAD_LICENSE DPERROR ( 0x23 ) *)
  { TODO : Macro uses commented-out symbol "DPERROR": }
  (* DPFPDD_E_PAD_FAILURE DPERROR ( 0x24 ) *)
  DPFPDD_HW_MODALITY_UNKNOWN = 0;
  DPFPDD_HW_MODALITY_SWIPE = 1;
  DPFPDD_HW_MODALITY_AREA = 2;
  DP_HW_TECHNOLOGY_UNKNOWN = 0;
  DP_HW_TECHNOLOGY_OPTICAL = 1;
  DP_HW_TECHNOLOGY_CAPACITIVE = 2;
  DP_HW_TECHNOLOGY_THERMAL = 3;
  DP_HW_TECHNOLOGY_PRESSURE = 4;
  MAX_STR_LENGTH = 128;
  MAX_DEVICE_NAME_LENGTH = 1024;
  DPFPDD_PRIORITY_COOPERATIVE = 2;
  DPFPDD_PRIORITY_EXCLUSIVE = 4;
  DPFPDD_STATUS_READY = 0;
  DPFPDD_STATUS_BUSY = 1;
  DPFPDD_STATUS_NEED_CALIBRATION = 2;
  DPFPDD_STATUS_FAILURE = 3;
  DPFPDD_QUALITY_GOOD = 0;
  DPFPDD_QUALITY_TIMED_OUT = 1;
  DPFPDD_QUALITY_CANCELED = (1 shl 1);
  DPFPDD_QUALITY_NO_FINGER = (1 shl 2);
  DPFPDD_QUALITY_FAKE_FINGER = (1 shl 3);
  DPFPDD_QUALITY_FINGER_TOO_LEFT = (1 shl 4);
  DPFPDD_QUALITY_FINGER_TOO_RIGHT = (1 shl 5);
  DPFPDD_QUALITY_FINGER_TOO_HIGH = (1 shl 6);
  DPFPDD_QUALITY_FINGER_TOO_LOW = (1 shl 7);
  DPFPDD_QUALITY_FINGER_OFF_CENTER = (1 shl 8);
  DPFPDD_QUALITY_SCAN_SKEWED = (1 shl 9);
  DPFPDD_QUALITY_SCAN_TOO_SHORT = (1 shl 10);
  DPFPDD_QUALITY_SCAN_TOO_LONG = (1 shl 11);
  DPFPDD_QUALITY_SCAN_TOO_SLOW = (1 shl 12);
  DPFPDD_QUALITY_SCAN_TOO_FAST = (1 shl 13);
  DPFPDD_QUALITY_SCAN_WRONG_DIRECTION = (1 shl 14);
  DPFPDD_QUALITY_READER_DIRTY = (1 shl 15);
  DPFPDD_IMG_FMT_PIXEL_BUFFER = 0;
  DPFPDD_IMG_FMT_ANSI381 = $001B0401;
  DPFPDD_IMG_FMT_ISOIEC19794 = $01010007;
  DPFPDD_IMG_PROC_DEFAULT = 0;
  DPFPDD_IMG_PROC_PIV = 1;
  DPFPDD_IMG_PROC_ENHANCED = 2;
  DPFPDD_IMG_PROC_ENHANCED_2 = 3;
  DPFPDD_IMG_PROC_UNPROCESSED = $52617749;
  DPFPDD_IMG_PROC_NONE = DPFPDD_IMG_PROC_DEFAULT;
  DPFPDD_LED_MAIN = $01;
  DPFPDD_LED_REJECT = $04;
  DPFPDD_LED_ACCEPT = $08;
  DPFPDD_LED_FINGER_DETECT = $10;
  DPFPDD_LED_AUX_1 = $14;
  DPFPDD_LED_AUX_2 = $18;
  DPFPDD_LED_PWM = $80;
  DPFPDD_LED_ALL = $ffffffff;
  DPFPDD_LED_AUTO = 1;
  DPFPDD_LED_CLIENT = 2;
  DPFPDD_LED_CLIENT_PWM = 3;
  DPFPDD_LED_CLIENT_BLINK = 4;
  DPFPDD_LED_CMD_OFF = 0;
  DPFPDD_LED_CMD_ON = 1;
  DPFPDD_LED_CMD_PWM_MIN = 0;
  DPFPDD_LED_CMD_PWM_MAX = 255;
  DPFPDD_CLIENT_PWM_SUPPORTED = $80000000;
  DPFPDD_CLIENT_BLINK_SUPPORTED = $40000000;
  DPFPDD_PARMID_ROTATE = $100;
  DPFPDD_PARMID_FINGERDETECT_ENABLE = $104;
  DPFPDD_PARMID_IOMAP = $105;
  DPFPDD_PARMID_MOTIONDETECT_ENABLE = $107;
  DPFPDD_PARMID_FRAME_INTERVAL = $110;
  DPFPDD_PARMID_PTAPI_GET_GUID = $302;
  DPFPDD_PARMID_PAD_ENABLE = $200;
  DPFPDD_PARMID_PAD_DP_ENABLE = $201;
  DPFPDD_PARMID_PAD_CONFIDENCE = $202;
  DPFPDD_PARMID_SPOOFDETECT_ENABLE = DPFPDD_PARMID_PAD_DP_ENABLE;

type
  // Forward declarations
  Pdpfpdd_ver_info = ^dpfpdd_ver_info;
  Pdpfpdd_version = ^dpfpdd_version;
  Pdpfpdd_hw_descr = ^dpfpdd_hw_descr;
  Pdpfpdd_hw_id = ^dpfpdd_hw_id;
  Pdpfpdd_hw_version = ^dpfpdd_hw_version;
  Pdpfpdd_dev_info = ^dpfpdd_dev_info;
  Pdpfpdd_dev_caps = ^dpfpdd_dev_caps;
  Pdpfpdd_dev_status = ^dpfpdd_dev_status;
  Pdpfpdd_capture_param = ^dpfpdd_capture_param;
  Pdpfpdd_image_info = ^dpfpdd_image_info;
  Pdpfpdd_capture_result = ^dpfpdd_capture_result;
  Pdpfpdd_capture_callback_data_0 = ^dpfpdd_capture_callback_data_0;
  Pdpfpdd_iomap = ^dpfpdd_iomap;

  (** 
  \brief Reader handle. 
  
  Calling dpfpdd_open() connects to a device and returns a handle.
  Open handles must be released when no longer needed by calling dpfpdd_close().
   *)
  DPFPDD_DEV = Pointer;
  PDPFPDD_DEV = ^DPFPDD_DEV;

  (**
  \brief API version information. 
   *)
  dpfpdd_ver_info = record
    (** major version number *)
    major: Integer;
    (** minor version number *)
    minor: Integer;
    (** maintenance or revision number *)
    maintenance: Integer;
  end;

  (**
  \brief Complete information about library/SDK.
   *)
  dpfpdd_version = record
    (** size of the structure, in bytes	*)
    size: Cardinal;
    (** file version of the SDK/library *)
    lib_ver: DPFPDD_VER_INFO;
    (** version of the API *)
    api_ver: DPFPDD_VER_INFO;
  end;

  (**
  \brief Reader modality.
   *)
  DPFPDD_HW_MODALITY = Cardinal;
  (** 
  \brief Reader technology.
   *)
  DPFPDD_HW_TECHNOLOGY = Cardinal;

  (**
  \brief Reader hardware descriptor.
   *)
  dpfpdd_hw_descr = record
    (** name of the vendor *)
    vendor_name: array [0..127] of AnsiChar;
    (** name of the product *)
    product_name: array [0..127] of AnsiChar;
    (** serial number *)
    serial_num: array [0..127] of AnsiChar;
  end;

  (**
  \brief Reader Hardware ID.
   *)
  dpfpdd_hw_id = record
    (** vendor ID (USB VID) *)
    vendor_id: Word;
    (** product ID (USB PID) *)
    product_id: Word;
  end;

  (**
  \brief Reader hardware version.
   *)
  dpfpdd_hw_version = record
    (** hardware version *)
    hw_ver: DPFPDD_VER_INFO;
    (** firmware version *)
    fw_ver: DPFPDD_VER_INFO;
    (** USB bcd revision *)
    bcd_rev: Word;
  end;

  (**
  \brief Complete information about reader hardware.
   *)
  dpfpdd_dev_info = record
    (** size of the structure *)
    size: Cardinal;
    (** unique name of the reader *)
    name: array [0..1023] of AnsiChar;
    (** displayable information about reader *)
    descr: DPFPDD_HW_DESCR;
    (** USB ID *)
    id: DPFPDD_HW_ID;
    (** reader hardware version information *)
    ver: DPFPDD_HW_VERSION;
    (** reader modality *)
    modality: DPFPDD_HW_MODALITY;
    (** reader technology *)
    technology: DPFPDD_HW_TECHNOLOGY;
  end;

  (**
  \brief Constants describing priority of the client opening the reader (Windows-only)
   *)
  DPFPDD_PRIORITY = Cardinal;

  (**
  \brief Information about reader capabilities.
   *)
  dpfpdd_dev_caps = record
    (** size of the structure *)
    size: Cardinal;
    (** flag: reader can capture images *)
    can_capture_image: Integer;
    (** flag: reader can stream images *)
    can_stream_image: Integer;
    (** flag: reader can extract features from captured image and return fingerprint features data *)
    can_extract_features: Integer;
    (** flag: reader can perform match one-to-one *)
    can_match: Integer;
    (** flag: reader can perform match one-to-many *)
    can_identify: Integer;
    (** flag: reader has storage for fingerprint features data *)
    has_fp_storage: Integer;
    (** bitmask: existing LEDs and supported LED modes (see DPFPDD_CLIENT_XXX_SUPPORTED)*)
    indicator_type: Cardinal;
    (** flag: power mode of the reader can be controlled  *)
    has_pwr_mgmt: Integer;
    (** flag: reader can be calibrated *)
    has_calibration: Integer;
    (** flag: can produce PIV compliant images *)
    piv_compliant: Integer;
    (** counter: number of the image resolutions reader can produce *)
    resolution_cnt: Cardinal;
    (** array: available resolutions *)
    resolutions: array [0..0] of Cardinal;
  end;

  (**
  \brief Constants describing status of the reader
   *)
  DPFPDD_STATUS = Cardinal;

  (**
  \brief Describes status of the reader
   *)
  dpfpdd_dev_status = record
    (** total size of the allocated memory including size of additional data *)
    size: Cardinal;
    (** reader status *)
    status: DPFPDD_STATUS;
    (** flag: finger detected on the reader *)
    finger_detected: Integer;
    (** additional vendor-specific data which may be passed by the driver *)
    data: array [0..0] of Byte;
  end;

  (**
  \brief Result of the capture operation
   *)
  DPFPDD_QUALITY = Cardinal;
  (**
  \brief Format of captured fingerprint image.
   *)
  DPFPDD_IMAGE_FMT = Cardinal;
  (**
  \brief Image processing.
   *)
  DPFPDD_IMAGE_PROC = Cardinal;

  (**
  \brief Describes image parameters for capture
   *)
  dpfpdd_capture_param = record
    (** size of the structure *)
    size: Cardinal;
    (** format of the image *)
    image_fmt: DPFPDD_IMAGE_FMT;
    (** processing of the image *)
    image_proc: DPFPDD_IMAGE_PROC;
    (** resolution of the image *)
    image_res: Cardinal;
  end;

  (**
  \brief Describes captured image
  
  The output parameter of the dpfpdd_capture() and dpfpdd_get_stream_image() functions. 
   *)
  dpfpdd_image_info = record
    (** size of the structure *)
    size: Cardinal;
    (** width of the captured image *)
    width: Cardinal;
    (** height of the captured image *)
    height: Cardinal;
    (** resolution of the captured image *)
    res: Cardinal;
    (** pixel depth of the captured image *)
    bpp: Cardinal;
  end;

  (**
  \brief Describes the result of the capture operation
   *)
  dpfpdd_capture_result = record
    (** size of the structure *)
    size: Cardinal;
    (** success flag; 0: capture failed, 1: capture succeeded, image is good *)
    success: Integer;
    (** image quality *)
    quality: DPFPDD_QUALITY;
    (** image score *)
    score: Cardinal;
    (** image info *)
    info: DPFPDD_IMAGE_INFO;
  end;

  (**
  \brief Describes the result of asynchronous capture operation
   *)
  dpfpdd_capture_callback_data_0 = record
    (** size of the structure *)
    size: Cardinal;
    (** error code *)
    error: Integer;
    (** capture parameters passed to dpfpdd_capture_async *)
    capture_parm: DPFPDD_CAPTURE_PARAM;
    (** result of the capture operation *)
    capture_result: DPFPDD_CAPTURE_RESULT;
    (** size of the image data *)
    image_size: Cardinal;
    (** image data *)
    image_data: PByte;
  end;

  (**
  \brief Callback for asynchronous capture
   *)
  DPFPDD_CAPTURE_CALLBACK = procedure(callback_context: Pointer; reserved: Cardinal; callback_data_size: Cardinal; callback_data: Pointer); stdcall;
  (**
  \brief LED identifiers
   *)
  DPFPDD_LED_ID = Cardinal;
  (**
  \brief LED operation mode
   *)
  DPFPDD_LED_MODE_TYPE = Cardinal;
  (**
  \brief LED state commands
   *)
  DPFPDD_LED_CMD_TYPE = Cardinal;
  (**
  \brief Reader and driver settings
   *)
  DPFPDD_PARMID = Cardinal;

  (**
  \brief I/O map setting parameters.
   *)
  dpfpdd_iomap = record
    (** I/O address or offset *)
    addr: Word;
    (** size size of the data buffer *)
    len: Word;
    (** data buffer *)
    buff: array [0..0] of Byte;
  end;

(**
	\brief Queries the library and API version information. 
	
	This is the only function which can be called before dpfpdd_init() or after dpfpdd_exit().
	
	\param ver  [in] Pointer to memory buffer; [out] Pointer to the version information (per DPFPDD_VERSION)
	\return DPFPDD_SUCCESS:   Version information was acquired;
	\return DPFPDD_E_FAILURE: Failed to acquire version information.
 *)
//manually edited:
//Original dpfpdd_version(...): Integer;
//changed to show_dpfpdd_version(...): Integer;
//Reason because, compiler recognize same name as record object and function
function show_dpfpdd_version(ver: PDPFPDD_VERSION): Integer; stdcall;
  external dpfpdd name _PU + 'dpfpdd_version';

(**
	\brief Library initialization.
	
	This function initializes the library. It must be called before calling any other functions from the library, except dpfpdd_version().
	
	\return DPFPDD_SUCCESS:   Library was initialized;
	\return DPFPDD_E_FAILURE: Failed to initialize library.
 *)
function dpfpdd_init(): Integer; stdcall;
  external dpfpdd name _PU + 'dpfpdd_init';

(**
	\brief Library release.
	
	This function releases the library. After calling this function the application can only call dpfpdd_version(), and  dpfpdd_init().
	
	\return DPFPDD_SUCCESS:   Library was released;
	\return DPFPDD_E_FAILURE: Failed to release library.
 *)
function dpfpdd_exit(): Integer; stdcall;
  external dpfpdd name _PU + 'dpfpdd_exit';

(**
	\brief Returns information about connected readers. 
	
	Client application must allocate memory for the list of the available devices and pass number of entries in the dev_cnt parameter. 
	If memory is not sufficient to contain information about all connected readers, then DPFPDD_E_MORE_DATA will be returned. 
	The number of connected devices will be returned in dev_cnt parameter.
	
	\param dev_cnt    [in] Number of entries in the dev_infos memory block; [out] Number of devices detected
	\param dev_infos  [in] Memory block; [out] Information about connected readers (per DPFPDD_DEV_INFO)
	\return DPFPDD_SUCCESS:      Information about connected readers obtained; 
	\return DPFPDD_E_FAILURE:    Unexpected failure;
	\return DPFPDD_E_MORE_DATA:	 Insufficient memory in dev_infos memory block for all readers. No data was returned. The required number of entries is in the dev_cnt.
 *)
function dpfpdd_query_devices(dev_cnt: PCardinal; dev_infos: PDPFPDD_DEV_INFO): Integer; stdcall;
  external dpfpdd name _PU + 'dpfpdd_query_devices';

(**
	\brief Opens a fingerprint reader in exclusive mode.

	If you or another process have already opened the reader, you cannot open it again.
	
	\param dev_name  Name of the reader, as acquired from dpfpdd_query_devices().
	\param pdev      [in] Pointer to empty handle (per DPFPDD_DEV); [out] Pointer to reader handle.
	\return DPFPDD_SUCCESS:             A valid reader handle is in the ppdev;
	\return DPFPDD_E_FAILURE:           Unexpected failure;
	\return DPFPDD_E_INVALID_PARAMETER: No reader with this name found;
	\return DPFPDD_E_DEVICE_BUSY:       Reader is already opened by the same or another process;
	\return DPFPDD_E_DEVICE_FAILURE:    Failed to open the reader.
 *)
function dpfpdd_open(dev_name: PAnsiChar; pdev: PDPFPDD_DEV): Integer; stdcall;
  external dpfpdd name _PU + 'dpfpdd_open';

(**
	\brief Opens a fingerprint reader.

	On Windows, client can choose if to open reader exclusively or in cooperative mode. In cooperative mode the process which has window in focus 
	will receive captured image.
	On Linux and Windows CE functionality is identical to dpfpdd_open. Priority is ignored and reader is always opened in exclusive mode.

	\param dev_name  Name of the reader, as acquired from dpfpdd_query_devices().
	\param priority  Priority of the client.
	\param pdev      [in] Pointer to empty handle (per DPFPDD_DEV); [out] Pointer to reader handle.
	\return DPFPDD_SUCCESS:             A valid reader handle is in the ppdev;
	\return DPFPDD_E_FAILURE:           Unexpected failure;
	\return DPFPDD_E_INVALID_PARAMETER: No reader with this name found;
	\return DPFPDD_E_DEVICE_BUSY:       Reader is already opened by the same or another process;
	\return DPFPDD_E_DEVICE_FAILURE:    Failed to open the reader.
 *)
function dpfpdd_open_ext(dev_name: PAnsiChar; priority: DPFPDD_PRIORITY; pdev: PDPFPDD_DEV): Integer; stdcall;
  external dpfpdd name _PU + 'dpfpdd_open_ext';

(**
	\brief Releases the reader.
	
	\param dev  Reader handle, as obtained from dpfpdd_open()
	\return DPFPDD_SUCCESS:          Reader closed, handle released
	\return DPFPDD_E_FAILURE:        Unexpected failure
	\return DPFPDD_E_INVALID_DEVICE: Invalid reader handle
	\return DPFPDD_E_DEVICE_BUSY:    Another operation is in progress
	\return DPFPDD_E_DEVICE_FAILURE: Failed to close the reader
 *)
function dpfpdd_close(dev: DPFPDD_DEV): Integer; stdcall;
  external dpfpdd name _PU + 'dpfpdd_close';

(**
	\brief Returns status of the reader.
	
	\param dev         Reader handle, as obtained from dpfpdd_open()
	\param dev_status  [in] Pointer to empty status (per DPFPDD_DEV_STATUS); [out] Pointer to  status of the reader
	\return DPFPDD_SUCCESS:             Reader status obtained
	\return DPFPDD_E_FAILURE:           Unexpected failure
	\return DPFPDD_E_INVALID_DEVICE:    Invalid reader handle
	\return DPFPDD_E_MORE_DATA:         Insufficient memory is allocated for the dev_status, the required size is in the dev_status.size
 *)
function dpfpdd_get_device_status(dev: DPFPDD_DEV; dev_status: PDPFPDD_DEV_STATUS): Integer; stdcall;
  external dpfpdd name _PU + 'dpfpdd_get_device_status';

(**
	\brief Queries hardware info and capabilities of the reader.
	
	Client application must allocate memory for the information about the reader. If the allocated memory is not sufficient to hold
	information about all resolutions, then DPFPDD_E_MORE_DATA will be returned. 
	The number of resolutions will be returned in the dev_caps.resolution_cnt field, and the required size of 
	the .dev_caps will be returned in the dev_caps.size field.
	
	\param dev       Reader handle, as obtained from dpfpdd_open();
	\param dev_caps  [in] Pointer empty info structure (per DPFPDD_DEV_CAPS); [out] Pointer to reader capabilities.
	\return DPFPDD_SUCCESS:             Reader capabilities obtained
	\return DPFPDD_E_FAILURE:           Unexpected failure
	\return DPFPDD_E_INVALID_DEVICE:    Invalid reader handle
	\return DPFPDD_E_DEVICE_BUSY:       Another operation is in progress
	\return DPFPDD_E_MORE_DATA:         Insufficient memory is allocated for the dev_caps, the required size is in the dev_caps.size
	\return DPFPDD_E_DEVICE_FAILURE:    Failed to obtain capabilities, reader is not functioning properly
 *)
function dpfpdd_get_device_capabilities(dev: DPFPDD_DEV; dev_caps: PDPFPDD_DEV_CAPS): Integer; stdcall;
  external dpfpdd name _PU + 'dpfpdd_get_device_capabilities';

(**
	\brief Capture a fingerprint image.

	This function captures a fingerprint image from the opened reader device.  
	This function signals the device that a fingerprint is expected and waits until a fingerprint is received.
	This function blocks until an image is captured, capture fails or timeout is expired. This function cannot 
	be called in streaming mode. Client application must allocate memory for the image_data. If memory 
	is not sufficient for the image, then DPFPDD_E_MORE_DATA will be returned. The required size of the 
	image_data will be returned in image_size parameter.
	
	\param dev              Reader handle, as obtained from dpfpdd_open()
	\param capture_parm     Defines data type and image format (per DPFPDD_CAPTURE_PARAM)
	\param timeout_cnt      Defines timeout in milliseconds; (unsigned int)(-1) means no timeout (function will block until a fingerprint is captured)
	\param capture_result   [in] Pointer to memory buffer; [out] Pointer to status of results (per DPFPDD_CAPTURE_RESULT)
	\param image_size       [in] Size of the allocated memory for the image_data; [out] Actual size needed for the image_data
	\param image_data       [in] Memory buffer; [out] Captured image
	\return DPFPDD_SUCCESS:             Image captured. Extended result is in capture_result
	\return DPFPDD_E_FAILURE:           Unexpected failure
	\return DPFPDD_E_INVALID_DEVICE:    Invalid reader handle
	\return DPFPDD_E_DEVICE_BUSY:       Another operation is in progress
	\return DPFPDD_E_MORE_DATA:         Insufficient  memory is allocated for the image_data, the required size is in the image_size
	\return DPFPDD_E_INVALID_PARAMETER: Wrong data type or image format in the capture_parm
	\return DPFPDD_E_DEVICE_FAILURE:    Failed to start capture, reader is not functioning properly
 *)
function dpfpdd_capture(dev: DPFPDD_DEV; capture_parm: PDPFPDD_CAPTURE_PARAM; timeout_cnt: Cardinal; capture_result: PDPFPDD_CAPTURE_RESULT; image_size: PCardinal; image_data: PByte): Integer; stdcall;
  external dpfpdd name _PU + 'dpfpdd_capture';

(**
	\brief Capture a fingerprint image asynchronously.

	This function starts asynchronous capture on the opened reader device.
	This function signals the device that a fingerprint is expected and then exits.
	
	\param dev             Reader handle, as obtained from dpfpdd_open()
	\param capture_parm    Defines data type and image format (per DPFPDD_CAPTURE_PARAM)
	\param context         Client context, passed into the callback
	\param callback        Address of the callback function, to be called when image is ready
	\return DPFPDD_SUCCESS:             Image captured. Extended result is in capture_result
	\return DPFPDD_E_FAILURE:           Unexpected failure
	\return DPFPDD_E_INVALID_DEVICE:    Invalid reader handle
	\return DPFPDD_E_DEVICE_BUSY:       Another operation is in progress
	\return DPFPDD_E_INVALID_PARAMETER: Wrong data type or image format in the capture_parm
	\return DPFPDD_E_DEVICE_FAILURE:    Failed to start capture, reader is not functioning properly
 *)
function dpfpdd_capture_async(dev: DPFPDD_DEV; capture_parm: PDPFPDD_CAPTURE_PARAM; context: Pointer; callback: DPFPDD_CAPTURE_CALLBACK): Integer; stdcall;
  external dpfpdd name _PU + 'dpfpdd_capture_async';

(**
	\brief Cancels pending capture.
	
	\param dev  Reader handle, as obtained from dpfpdd_open();
	\return DPFPDD_SUCCESS:          Capture canceled
	\return DPFPDD_E_FAILURE:        Unexpected failure
	\return DPFPDD_E_INVALID_DEVICE: Invalid reader handle
	\return DPFPDD_E_DEVICE_FAILURE: Failed to cancel capture, reader is not functioning properly
 *)
function dpfpdd_cancel(dev: DPFPDD_DEV): Integer; stdcall;
  external dpfpdd name _PU + 'dpfpdd_cancel';

(**
	\brief Puts reader into streaming mode.
	
	Not all readers support this mode. When the reader is in streaming mode, the application can only call 
	dpfpdd_get_stream_image() to acquire images from the stream.
	
	\param dev  Reader handle, as obtained from dpfpdd_open()
	\return DPFPDD_SUCCESS:          Reader put into streaming mode
	\return DPFPDD_E_FAILURE:        Unexpected failure
	\return DPFPDD_E_INVALID_DEVICE: Invalid reader handle
	\return DPFPDD_E_DEVICE_BUSY:    Another operation is in progress
	\return DPFPDD_E_DEVICE_FAILURE: Failed to start streaming, reader is not functioning properly
 *)
function dpfpdd_start_stream(dev: DPFPDD_DEV): Integer; stdcall;
  external dpfpdd name _PU + 'dpfpdd_start_stream';

(**
	\brief Stops streaming mode.
	
	\param dev  Reader handle, obtained from dpfpdd_open()
	\return DPFPDD_SUCCESS:          Streaming was stopped
	\return DPFPDD_E_FAILURE:        Unexpected failure
	\return DPFPDD_E_INVALID_DEVICE: Invalid reader handle
	\return DPFPDD_E_DEVICE_FAILURE: Failed to stop streaming, reader is not functioning properly
 *)
function dpfpdd_stop_stream(dev: DPFPDD_DEV): Integer; stdcall;
  external dpfpdd name _PU + 'dpfpdd_stop_stream';

(**
	\brief Takes an image from the stream.
	
	After the reader is put into streaming mode this function takes an image from the stream. After this function returns, the  
	reader stays in the streaming mode. Frame selection, scoring or other image processing is not performed.
	
	The client application must allocate memory for the image_data. If the memory is not sufficient for the image, then 
	DPFPDD_E_MORE_DATA will be returned. The required size of the image_data will be returned in the image_size parameter.
	For every image from the stream, the driver provides a score (in capture_result.score) and quality feedback (in capture_result.quailty). 
	
	\param dev             Reader handle, obtained from dpfpdd_open()
	\param capture_parm    Defines data type and image format (per DPFPDD_CAPTURE_PARAM)
	\param capture_result  Pointer to the structure to receive result of the capture (per DPFPDD_CAPTURE_RESULT)
	\param image_size      [in] Size of the allocated memory for the image_data; [out] Actual size needed for the image_data
	\param image_data      Receives captured image
	\return DPFPDD_SUCCESS:             Image acquired from the stream. Extended result is in capture_result
	\return DPFPDD_E_FAILURE:           Unexpected failure
	\return DPFPDD_E_INVALID_DEVICE:    Invalid reader handle
	\return DPFPDD_E_DEVICE_BUSY:       Another operation is in progress
	\return DPFPDD_E_MORE_DATA:         Insufficient  memory is allocated for the image_data, the required size is in the image_size
	\return DPFPDD_E_INVALID_PARAMETER: Wrong data type or image format in the capture_parm
	\return DPFPDD_E_DEVICE_FAILURE:    Failed to acquire image from the stream, reader is not functioning properly
 *)
function dpfpdd_get_stream_image(dev: DPFPDD_DEV; capture_parm: PDPFPDD_CAPTURE_PARAM; capture_result: PDPFPDD_CAPTURE_RESULT; image_size: PCardinal; image_data: PByte): Integer; stdcall;
  external dpfpdd name _PU + 'dpfpdd_get_stream_image';

(**
	\brief Resets the reader.
	
	This function performs a hardware reset on the reader.  Hardware resets are typically needed only 
	after a hardware problem (e.g., the reader is unplugged or receives an electrostatic shock). 
	This function blocks until the reset is complete.

	\param dev  Reader handle, as obtained from dpfpdd_open();
	\return DPFPDD_SUCCESS:          Reset succeeded;
	\return DPFPDD_E_FAILURE:        Unexpected failure;
	\return DPFPDD_E_INVALID_DEVICE: Invalid reader handle;
	\return DPFPDD_E_DEVICE_BUSY:    Another operation is in progress;
	\return DPFPDD_E_DEVICE_FAILURE: Failed to reset, reader is not functioning properly.
 *)
function dpfpdd_reset(dev: DPFPDD_DEV): Integer; stdcall;
  external dpfpdd name _PU + 'dpfpdd_reset';

(**
	\brief Calibrates the reader.

	This function calibrates a reader and blocks until the calibration is complete.  It can take several seconds to calibrate for some devices.
	
	\param dev  Reader handle, as obtained from dpfpdd_open();
	\return DPFPDD_SUCCESS:          Calibration succeeded
	\return DPFPDD_E_FAILURE:        Unexpected failure
	\return DPFPDD_E_INVALID_DEVICE: Invalid reader handle
	\return DPFPDD_E_DEVICE_BUSY:    Another operation is in progress
	\return DPFPDD_E_DEVICE_FAILURE: Failed to calibrate, reader is not functioning properly
 *)
function dpfpdd_calibrate(dev: DPFPDD_DEV): Integer; stdcall;
  external dpfpdd name _PU + 'dpfpdd_calibrate';

(**
	\brief Sets configuration parameters for LED.

	Function sets operation mode for LED: automatic or controlled by client application.

	\param dev         Reader handle, as obtained from dpfpdd_open().
	\param led_id      LED type.
	\param led_mode    LED operation mode.
	\param reserved    Reserved for future use, must be NULL.
 *)
function dpfpdd_led_config(dev: DPFPDD_DEV; led_id: DPFPDD_LED_ID; led_mode: DPFPDD_LED_MODE_TYPE; reserved: Pointer): Integer; stdcall;
  external dpfpdd name _PU + 'dpfpdd_led_config';

(**
	\brief Turns LED on/off or starts LED event

	If LED is controlled by client application this function allows to turn LED on or off.
	LED must be configured by calling dpfpdd_led_config().

	\param dev      Reader handle, as obtained from dpfpdd_open().
	\param led_id   LED type.
	\param led_cmd  LED command.
 *)
function dpfpdd_led_ctrl(dev: DPFPDD_DEV; led_id: DPFPDD_LED_ID; led_cmd: DPFPDD_LED_CMD_TYPE): Integer; stdcall;
  external dpfpdd name _PU + 'dpfpdd_led_ctrl';

(**
	\brief Changes reader or driver setting.
	
	\param dev      Reader handle, as obtained from dpfpdd_open();
	\param parm_id  Parameter ID;
	\param size     Size of the parameter buffer;
	\param buffer   Parameter buffer;
	\return DPFPDD_SUCCESS:             Parameter was set
	\return DPFPDD_E_FAILURE:           Unexpected failure
	\return DPFPDD_E_INVALID_DEVICE:    Invalid reader handle
	\return DPFPDD_E_DEVICE_BUSY:       Another operation is in progress
	\return DPFPDD_E_INVALID_PARAMETER: Parameter ID is incorrect or not supported
	\return DPFPDD_E_DEVICE_FAILURE:    Failed to set parameter, reader is not functioning properly
 *)
function dpfpdd_set_parameter(dev: DPFPDD_DEV; parm_id: DPFPDD_PARMID; size: Cardinal; buffer: PByte): Integer; stdcall;
  external dpfpdd name _PU + 'dpfpdd_set_parameter';

(** \brief Reads reader or driver setting.
	 
	\param dev      Reader handle, obtained from dpfpdd_open();
	\param parm_id  Parameter ID;
	\param size     Size of the parameter buffer;
	\param buffer   Parameter buffer;
	\return DPFPDD_SUCCESS:             Parameter was set
	\return DPFPDD_E_FAILURE:           Unexpected failure
	\return DPFPDD_E_INVALID_DEVICE:    Invalid reader handle
	\return DPFPDD_E_DEVICE_BUSY:       Another operation is in progress
	\return DPFPDD_E_INVALID_PARAMETER: Parameter ID is incorrect or not supported
	\return DPFPDD_E_DEVICE_FAILURE:    Failed to set parameter, reader is not functioning properly
 *)
function dpfpdd_get_parameter(dev: DPFPDD_DEV; parm_id: DPFPDD_PARMID; size: Cardinal; buffer: PByte): Integer; stdcall;
  external dpfpdd name _PU + 'dpfpdd_get_parameter';

implementation

end.